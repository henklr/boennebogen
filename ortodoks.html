<!DOCTYPE html>
<html lang="da">
<head>
  <link rel="icon" href="favicon.png" type="image/png">
  <link rel="apple-touch-icon" href="/icon.jpg">
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Ortodokse Bønner</title>
  <meta name="theme-color" content="#0f172a">
  <link rel="stylesheet" href="style.css">
  <link rel="preload" href="bg-main-menu.jpg" as="image">
  <link rel="preload" href="bg-ortodoks-morgen.jpg" as="image">
  <link rel="preload" href="bg-ortodoks-aften.jpg" as="image">
  <link rel="preload" href="bg-joyful.jpg" as="image">
  <link rel="preload" href="bg-luminous.jpg" as="image">
  <link rel="preload" href="bg-sorrowful.jpg" as="image">
  <link rel="preload" href="bg-glorious.jpg" as="image">
  <script src="prayers.js"></script>

  <!-- Inline helper CSS for the fixed/scrollable overview (move to style.css if you prefer) -->
  <style>
    .card details[open] #overview {
      height: clamp(240px, 40vh, 420px);
      overflow-y: auto;
      overscroll-behavior: contain;
      padding-right: 6px;
      scroll-behavior: smooth;
      border-radius: 10px;
      -webkit-overflow-scrolling: touch;
    }
  </style>
</head>
<body class="ortodoks">
  <div class="bg"></div>
  <header>
    <div class="inner">
      <a href="/" class="home-btn" aria-label="Hjem" title="Tilbage til forsiden">◀</a>
      <div class="row">
        <label class="pill" title="Vælg version">
          <select id="versionSelect" aria-label="Vælg version">
            <option value="false">Lang</option>
            <option value="true">Kort</option>
          </select>
        </label>
        <label class="pill" title="Vælg bønnesæt">
          <select id="setSelect" aria-label="Vælg bønnesæt">
            <option value="0">Morgenbønner</option>
            <option value="1">Aftenbønner</option>
          </select>
        </label>
      </div>
    </div>
  </header>

  <main class="app">
    <section class="grid">
      <div class="card">
        <div class="kicker">Aktuelt bønnesæt</div>
        <h2 id="setTitle">Morgenbønner</h2>
        <div class="muted" id="setSubtitle">Bedes dagligt ved opvågnen</div>
        <div class="progress" aria-label="Fremskridt"><div id="progressFill" style="width: 2.9%;"></div></div>
      </div>

      <div class="card" id="currentCard">
        <div class="kicker" id="currentKind">Indledning</div>
        <div id="currentTitle" class="big" style="margin:6px 0 8px">Korsets tegn</div>
        <div id="currentBody">I Faderens og Sønnens og Helligåndens navn. Amen.</div>
      </div>

      <div class="card">
        <details id="overviewDetails">
          <summary><strong>Oversigt</strong> – hele forløbet</summary>
          <div id="overview" class="list" style="margin-top:10px"></div>
        </details>
      </div>

      <div class="card">
        <details>
          <summary><strong>Hjælp</strong> – sådan beder du de ortodokse bønner</summary>
          <ol>
            <li>Stå foran ikonerne, gør korsets tegn og begynd med indledningsbønner.</li>
            <li>Bed roligt og opmærksomt, gerne højt eller i en hvisken, for at holde fokus.</li>
            <li><strong>Morgenbønner</strong>: Følg rækkefølgen: Korsets tegn, indledningsbønner, Jesusbønnen (gentages), Trosbekendelsen, og afsluttende bønner.</li>
            <li><strong>Aftenbønner</strong>: Følg rækkefølgen: Korsets tegn, bøn om tilgivelse, Jesusbønnen (gentages), bøn til Theotokos, og bøn før søvn.</li>
            <li>På fastedage (onsdag og fredag) kan røgelse tændes; på søndage tændes lys og røgelse.</li>
            <li>Bed med ydmyghed og koncentration, og afslut med korsets tegn.</li>
          </ol>
        </details>
      </div>
    </section>
  </main>

  <nav class="actions" aria-label="Kontroller">
    <div class="bar">
      <button id="restartBtn" class="btn" aria-label="Genstart">↺ Genstart</button>
      <button id="prevBtn" class="btn" aria-label="Forrige" disabled>◀ Forrige</button>
      <button id="nextBtn" class="btn primary" aria-label="Næste">Næste ▶</button>
    </div>
  </nav>

  <script>
    // Bønnesæt
    const PRAYER_SETS = {
      Morning: {
        name: "Morgenbønner",
        subtitle: "Bedes dagligt ved opvågnen",
        image: "bg-ortodoks-morgen.jpg",
        items: [
          { title: prayers.signOfCross.title, body: prayers.signOfCross.body, kind: "Indledning" },
          { title: prayers.tolder.title, body: prayers.tolder.body, kind: "Indledning" },
          { title: prayers.indledning_othodox.title, body: prayers.indledning_othodox.body, kind: "Indledning" },
          { title: prayers.morgenTroparier.title, body: prayers.morgenTroparier.body, kind: "Troparier" },
          { title: prayers.basiliosDenStore.title, body: prayers.basiliosDenStore.body, kind: "Bøn" },
          { title: prayers.salme51.title, body: prayers.salme51.body, kind: "Salme" },
          { title: prayers.creed_orthodox.title, body: prayers.creed_orthodox.body, kind: "Trosbekendelse" },
          { title: prayers.makariosDenStore_morgen.title, body: prayers.makariosDenStore_morgen.body, kind: "Bøn" },
          { title: prayers.basiliosDenStore2.title, body: prayers.basiliosDenStore2.body, kind: "Bøn" },
          { title: prayers.bønTilSkytsenglen_morgen.title, body: prayers.bønTilSkytsenglen_morgen.body, kind: "Bøn" },
          { title: prayers.bønTilGudfødersken.title, body: prayers.bønTilGudfødersken.body, kind: "Bøn" },
          { title: prayers.bønForDeLevende.title, body: prayers.bønForDeLevende.body, kind: "Bøn" },
          { title: prayers.bønForDeHensovne.title, body: prayers.bønForDeHensovne.body, kind: "Bøn" },
          { title: prayers.faderSophronij.title, body: prayers.faderSophronij.body, kind: "Bøn" },
          { title: prayers.closing_orthodox.title, body: prayers.closing_orthodox.body, kind: "Afslutning" }
        ]
      },
      Evening: {
        name: "Aftenbønner",
        subtitle: "Bedes dagligt før søvn",
        image: "bg-ortodoks-aften.jpg",
        items: [
          { title: prayers.signOfCross.title, body: prayers.signOfCross.body, kind: "Indledning" },
          { title: prayers.tolder.title, body: prayers.tolder.body, kind: "Indledning" },
          { title: prayers.indledning_othodox.title, body: prayers.indledning_othodox.body, kind: "Indledning" },
          { title: prayers.troparier.title, body: prayers.troparier.body, kind: "Troparier" },
          { title: prayers.creed_orthodox.title, body: prayers.creed_orthodox.body, kind: "Trosbekendelse" },
          { title: prayers.makariosDenStore_aften.title, body: prayers.makariosDenStore_aften.body, kind: "Bøn" },
          { title: prayers.antiokos.title, body: prayers.antiokos.body, kind: "Bøn" },
          { title: prayers.johannesChrysostomos.title, body: prayers.johannesChrysostomos.body, kind: "Bøn" },
          { title: prayers.bønTilDenAlreneGudsmoder.title, body: prayers.bønTilDenAlreneGudsmoder.body, kind: "Bøn" },
          { title: prayers.bønTilSkytsenglen_aften.title, body: prayers.bønTilSkytsenglen_aften.body, kind: "Bøn" },
          { title: prayers.tilGudsmoder.title, body: prayers.tilGudsmoder.body, kind: "Bøn" },
          { title: prayers.bønTilTreenigheden.title, body: prayers.bønTilTreenigheden.body, kind: "Bøn" },
          { title: prayers.closing_orthodox.title, body: prayers.closing_orthodox.body, kind: "Afslutning" }
        ]
      }
    };

    // Hvilket sæt pr. valg
    function setToKey(s) {
      const map = {
        0: 'Morning',
        1: 'Evening'
      };
      return map[s] || 'Morning';
    }

    // Byg rækken af trin for et valgt bønnesæt
    function buildSequence(setKey, isSimpleVersion) {
      const set = PRAYER_SETS[setKey];
      let seq = [];

      if (isSimpleVersion) {
        // Simpel version: Kun essentielle bønner
        seq = [
          { title: prayers.signOfCross.title, body: prayers.signOfCross.body, kind: "Indledning" },
          { title: prayers.tolder.title, body: prayers.tolder.body, kind: "Indledning" },
          { title: prayers.indledning_othodox.title, body: prayers.indledning_othodox.body, kind: "Indledning" },
          { title: prayers.jesusPrayer.title, body: prayers.jesusPrayer.body + '\n\n(Gentages 10 gange)', kind: "Bøn" },
          { title: prayers.theotokos.title, body: prayers.theotokos.body, kind: "Bøn" },
          { title: prayers.creed_orthodox.title, body: prayers.creed_orthodox.body, kind: "Trosbekendelse" },
          { title: prayers.closing_orthodox.title, body: prayers.closing_orthodox.body, kind: "Afslutning" }
        ];
        if (setKey === 'Evening') {
          seq.splice(4, 0, { title: prayers.eveningForgiveness.title, body: prayers.eveningForgiveness.body, kind: "Bøn" });
        }
      } else {
        // Fuld version: Alle bønner fra sættet
        seq = set.items;
      }

      return { seq, set };
    }

    // UI state
    const state = {
      setKey: null,
      sequence: [],
      i: 0,
      isSimpleVersion: false
    };

    const els = {
      setSelect: document.getElementById('setSelect'),
      versionSelect: document.getElementById('versionSelect'),
      setTitle: document.getElementById('setTitle'),
      setSubtitle: document.getElementById('setSubtitle'),
      currentKind: document.getElementById('currentKind'),
      currentTitle: document.getElementById('currentTitle'),
      currentBody: document.getElementById('currentBody'),
      progressFill: document.getElementById('progressFill'),
      nextBtn: document.getElementById('nextBtn'),
      prevBtn: document.getElementById('prevBtn'),
      restartBtn: document.getElementById('restartBtn'),
      overview: document.getElementById('overview'),
      bg: document.querySelector('.bg'),
      currentCard: document.getElementById('currentCard'),
      overviewDetails: document.getElementById('overviewDetails') // <-- added
    };

    function selectSetForUI() {
      const sel = els.setSelect.value;
      const key = setToKey(sel);
      loadSet(key);
    }

    function loadSet(key) {
      const built = buildSequence(key, state.isSimpleVersion);
      state.setKey = key;
      state.sequence = built.seq;
      state.i = 0;
      // Header
      els.setTitle.textContent = PRAYER_SETS[key].name;
      els.setSubtitle.textContent = PRAYER_SETS[key].subtitle;
      // Set background image
      els.bg.style.backgroundImage = `url(${PRAYER_SETS[key].image})`;
      // Oversigt
      renderOverview();
      // Første trin
      renderStep();
    }

    // helper: keep the active step near the top of the overview scrollbox
    function scrollOverviewToActive(behavior = 'auto') {
      const active = els.overview.querySelector('.item.active');
      if (!active) return;

      const gap = 50; // px breathing room
      const padTop = parseFloat(getComputedStyle(els.overview).paddingTop) || 0;
      const targetTop = Math.max(0, active.offsetTop - padTop - gap);

      els.overview.scrollTo({ top: targetTop, behavior });
    }

    function renderOverview() {
      els.overview.innerHTML = '';
      state.sequence.forEach((s, idx) => {
        const div = document.createElement('div');
        div.className = 'item' + (idx === state.i ? ' active' : '');
        div.innerHTML = `<div class="kicker">${s.kind}</div><div> ${s.title}</div>`;
        div.addEventListener('click', () => { state.i = idx; renderStep(); });
        els.overview.appendChild(div);
      });
    }

    function renderStep() {
      const s = state.sequence[state.i];
      els.currentKind.textContent = s.kind;
      els.currentTitle.textContent = s.title;
      els.currentBody.innerHTML = s.body.replace(/\n/g, "<br>");
      // Progress
      const pct = ((state.i + 1) / state.sequence.length) * 100;
      els.progressFill.style.width = pct.toFixed(1) + '%';
      // Buttons
      els.prevBtn.disabled = state.i === 0;
      els.nextBtn.textContent = (state.i === state.sequence.length - 1) ? 'Færdig ✔' : 'Næste ▶';
      // Keep current card visible below sticky header
      const headerHeight = document.querySelector('header').offsetHeight || 0;
      const extraOffset = 10;
      const cardTop = els.currentCard.getBoundingClientRect().top;
      if (cardTop < headerHeight) {
        const scrollTop = els.currentCard.getBoundingClientRect().top + window.scrollY - headerHeight - extraOffset;
        window.scrollTo({ top: scrollTop, behavior: 'smooth' });
      }
      // Re-render overview, then align it
      renderOverview();
      scrollOverviewToActive('auto'); // set to 'smooth' if you prefer
    }

    function next() { if (state.i < state.sequence.length - 1) { state.i++; renderStep(); } }
    function prev() { if (state.i > 0) { state.i--; renderStep(); } }
    function restart() { state.i = 0; renderStep(); }

    function toggleVersion() {
      state.isSimpleVersion = els.versionSelect.value === 'true';
      selectSetForUI();
    }

    function loadPrefs() {
      const now = new Date();
      const hour = now.getHours();
      els.setSelect.value = hour < 16 ? '0' : '1';
      els.versionSelect.value = state.isSimpleVersion ? 'true' : 'false';
      selectSetForUI();
    }

    // Events
    els.nextBtn.addEventListener('click', next);
    els.prevBtn.addEventListener('click', prev);
    els.restartBtn.addEventListener('click', restart);
    els.setSelect.addEventListener('change', () => { selectSetForUI(); });
    els.versionSelect.addEventListener('change', toggleVersion);

    // When the overview <details> opens, align the active item to the top with a gap
    els.overviewDetails.addEventListener('toggle', () => {
      if (els.overviewDetails.open) {
        setTimeout(() => scrollOverviewToActive('smooth'), 0);
      }
    });

    // Gestus: tryk på teksten for næste
    document.getElementById('currentCard').addEventListener('click', () => { next(); });

    // Tastatur (space/enter/venstre/højre)
    window.addEventListener('keydown', (e) => {
      if (['INPUT', 'TEXTAREA', 'SELECT'].includes((e.target || {}).tagName)) return;
      if (e.key === 'ArrowRight' || e.key === ' ' || e.key === 'Enter') { e.preventDefault(); next(); }
      if (e.key === 'ArrowLeft') { e.preventDefault(); prev(); }
    });

    // Init
    loadPrefs();
  </script>
<script>
  // === CONFIG ===
  const LOG_ENDPOINT = "/api/ortodoks/logs";
  const LOG_BATCH_SIZE = 10;      // can re-enable batching later
  const LOG_FLUSH_MS  = 5000;

  // limits to avoid giant POSTs / localStorage quota
  const MAX_STASH_ENTRIES    = 2000;
  const MAX_ENTRIES_PER_POST = 50;
  const MAX_BODY_BYTES       = 120 * 1024;

  console.log("ortodoks-log: script loaded");

  // === SESSION-ID ===
  const sessionId = (crypto && crypto.randomUUID)
    ? crypto.randomUUID()
    : (Date.now().toString(36) + Math.random().toString(36).slice(2));

  // === QUEUE / STASH HELPERS ===
  const logQueue = [];
  let flushTimer = null;
  let isFlushing = false;

  function getStash() {
    try { return JSON.parse(localStorage.getItem("ortodoks_log_stash") || "[]"); }
    catch { return []; }
  }
  function setStash(arr) {
    try {
      if (arr.length > MAX_STASH_ENTRIES) arr = arr.slice(-MAX_STASH_ENTRIES);
      localStorage.setItem("ortodoks_log_stash", JSON.stringify(arr));
    } catch {
      try { localStorage.setItem("ortodoks_log_stash", JSON.stringify(arr.slice(-200))); } catch {}
    }
  }

  function buildChunk(fromArr) {
    const out = [];
    for (let i = 0; i < fromArr.length && out.length < MAX_ENTRIES_PER_POST; i++) {
      const candidate = fromArr[i];
      const tentative = JSON.stringify({ entries: out.concat([candidate]) });
      if (tentative.length > MAX_BODY_BYTES) break;
      out.push(candidate);
    }
    return out;
  }

  function scheduleFlush() {
    if (flushTimer) return;
    flushTimer = setTimeout(flushLogs, LOG_FLUSH_MS);
  }

  // send immediately (you can switch back to batching later)
  function enqueueLog(event) {
    logQueue.push(event);
    flushLogs().catch(err => console.error("ortodoks flush error", err));
    // To batch instead:
    // if (logQueue.length >= LOG_BATCH_SIZE) flushLogs().catch(()=>{});
    // else scheduleFlush();
  }

  async function flushLogs(useBeacon = false) {
    if (isFlushing) return;
    clearTimeout(flushTimer);
    flushTimer = null;

    const stash = getStash();
    if (stash.length === 0 && logQueue.length === 0) return;

    const merged = stash.concat(logQueue.splice(0));
    const chunk = buildChunk(merged);
    if (chunk.length === 0) return;

    const bodyStr = JSON.stringify({ entries: chunk });
    isFlushing = true;

    try {
      if (useBeacon && navigator.sendBeacon) {
        const ok = navigator.sendBeacon(LOG_ENDPOINT, new Blob([bodyStr], { type: "application/json" }));
        if (!ok) throw new Error("sendBeacon returned false");
      } else {
        const res = await fetch(LOG_ENDPOINT, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: bodyStr,
          keepalive: true
        });
        if (!res.ok) throw new Error("HTTP " + res.status);
      }

      const remaining = merged.slice(chunk.length);
      setStash(remaining);

      if (remaining.length > 0 || logQueue.length > 0) {
        setTimeout(() => { isFlushing = false; flushLogs().catch(()=>{}); }, 50);
        return;
      }
    } catch (err) {
      setStash(merged.concat(logQueue.splice(0)));
      console.warn("ortodoks flush failed, will retry later:", err);
    } finally {
      isFlushing = false;
    }
  }

  // Flush when tab is hidden/closed
  document.addEventListener("visibilitychange", () => {
    if (document.visibilityState !== "visible") flushLogs(true);
  });
  window.addEventListener("pagehide", () => flushLogs(true));

  // === BUILD & SEND ONE ENTRY FOR CURRENT STEP ===
  function logRenderStepServer() {
    const now = new Date().toISOString();
    const current = (state?.i ?? 0) + 1;
    const total   = state?.sequence?.length ?? 0;
    const setKey  = state?.setKey ?? "unknown";              // 'Morning' | 'Evening'
    const setName = (PRAYER_SETS?.[setKey]?.name) || setKey; // "Morgenbønner" | "Aftenbønner"
    const s = (state?.sequence?.[state?.i || 0]) || {};
    const stepTitle = s.title || "";
    const kind      = s.kind || "";

    enqueueLog({
      ts: now,
      sessionId,
      setKey,
      setName,
      stepTitle,
      kind,
      step: current,
      total,
      versionSimple: !!(state?.isSimpleVersion),
      page: "ortodoks",
      locale: navigator.language || "da",
      ua: navigator.userAgent
    });
  }

  // === PATCH renderStep so every render logs, plus first render ===
  (function patchRenderStepForLogging() {
    if (typeof window.renderStep !== "function") {
      console.warn("ortodoks-log: renderStep not found yet – retry soon");
      setTimeout(patchRenderStepForLogging, 0);
      return;
    }
    const originalRenderStep = window.renderStep;
    window.renderStep = function() {
      const ret = originalRenderStep.apply(this, arguments);
      logRenderStepServer();
      return ret;
    };
    console.log("ortodoks-log: renderStep patched");

    // log initial render (the one that happened before patch)
    if (state?.sequence?.length) logRenderStepServer();
  })();
</script>
</body>
</html>
